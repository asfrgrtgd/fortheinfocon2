[Scene]
background = (0.8, 0.9, 1.0)

[linearSearch]
str = 全ての要素を一つづつ確認するという非常にシンプルなアルゴリズムであり、データの整列や前処理が要らないため、汎用性が高いアルゴリズムです。\nただし、要素数nとして最悪の場合にはすべての要素を確認する必要があるため時間計算量がO(n)です。処理された大きいデータ構造や何回も同じデータ構造を探索をする際には、二分探索O(log2(n))より遅くなる可能性があります。\n空間計算量は追加のメモリを必要としないのでO(1)です。
detailStr = 初期設定\nランダム生成ボタンで検索対象の配列をランダムに生成します、検索値の下のテキストボックスに二桁以内の整数を入力する事で探索する数値を決定されます、ステップボタンで線形探索を１ステップ進めます。\n※ステップボタンを一度押すと設定は変更不可です
algoHeadStr = 配列の{}番目の要素は{}、検索値は{}で

[binarySearch]
str = データ構造や関数や数列に対してある要素が存在するか探したり、ある要素以下の最大の数を探したりする際に使えるアルゴリズムです。\nこのアルゴリズムは探索する対象のデータ構造が単調性を持っている事が条件です。\nここでの単調性とは全ての要素間を比較したときにv[k] <= v[k + 1]もしくはv[k] >= v[k + 1] (v[k]は配列のk番目の要素) が成り立つ事を意味します。\n探索範囲は各ステップで1/2ずつ減っていくので最悪のケースでも(log2(n))回になり、時間計算量はO(log2(n))と高速です。\n空間計算量は追加のメモリをほとんど必要としないのでO(1)です。
detailStr = 初期設定\nランダム生成ボタンで検索対象の昇順の配列をランダムに生成します、検索値の下のテキストボックスに二桁以内の整数を入力する事で探索する数値を決定されます、ステップボタンで二分探索を１ステップ進めます。\n※ステップボタンを一度押すと設定は変更不可です

[breadthFirstSearch]
str = ある地点からある地点までの最短経路を見つける為のアルゴリズムであり、すべての経路を一度に探索していくため、どのような構造でも最短経路を確実に見つける事が出来ます。\nまた、キューという先入れ先出しデータ構造を使う事で、探索する候補を管理しています。最悪の場合でも同じマスから複数回探索する事はないのでマス目をnとして時間計算量はO(n)になります。\n空間計算量はキューを最大nマス分使うのでO(n)です。
detailStr1 = 初期設定\n手動生成を押す事で探索する対象の迷路を手動で作れます、ステップボタンで幅優先探索を１ステップ進めます。また、迷路は一番左上のマスを(1,1)一番右下のマスを(6,6)と表します\n※ステップボタンを一度押すと設定は変更不可です
detailStr2 = マス目にマウスカーソルを合わせた状態でキーボードのSキーを押すとスタート地点として設定します、Gキーを押してゴール地点として設定します。通れない壁は左クリックを押すと生成されます、右クリックでマス目を元の何もない状態に戻します。\n迷路を作れたらステップボタンを押す事で幅優先探索に移行します(スタート地点が無い,二個以上、またはゴール地点が無い,二個以上の迷路はサンプルの迷路に置き換わります)

[depthFirstSearch]
str = 迷路やグラフを探索する際に、まず可能な限り一つの方向に深く進み、その後に戻って別の道を探索するアルゴリズムです。このアルゴリズムは、最初にスタート地点から一方向に進めるだけ進み、行き止まりに達すると、バックトラックして別の道を探索するというプロセスを繰り返します。\n最悪の場合でも同じマスから複数回探索する事はないのでマス目をnとして時間計算量はO(n)になります。\n空間計算量は、スタックを利用して次の探索地点を管理するため、探索の深さに依存しO(n)です。深さ優先探索は、可能な限りルートを進む性質上、必ずしも最短経路を探索出来る訳ではありません。
detailStr1 = 初期設定\n手動生成を押す事で探索する対象の迷路を手動で作れます、ステップボタンで深さ優先探索を１ステップ進めます。ここでのバックトラックとは探索の途中まで巻き戻す操作の事です。また、迷路は一番左上のマスを(1,1)一番右下のマスを(6,6)と表します\n※ステップボタンを一度押すと設定は変更不可です
detailStr2 = マス目にマウスカーソルを合わせた状態でキーボードのSキーを押すとスタート地点として設定します、Gキーを押してゴール地点として設定します。通れない壁は左クリックを押すと生成されます、右クリックでマス目を元の何もない状態に戻します。\n迷路を作れたらステップボタンを押す事で深さ優先探索に移行します(スタート地点が無い,二個以上、またはゴール地点が無い,二個以上の迷路はサンプルの迷路に置き換わります)

[euclideanAlgorithm]
str = 最大公約数を効率よく求めるアルゴリズムです。具体的には二つの整数x,y(x > y)をxをyで割り、その余りrをrが0になるまでxにyを代入して、yにrを代入するという動作を繰り返し、yの値が最終的にx,byの最大公約数になります。\nこのアルゴリズムの計算量の導出はステップを二つの場合に分けて導きます、y <= x / 2の時rはr < y <= x / 2になり、y > x / 2の時は割り切れないのでr = x - yとなりr < x / 2になります。そのためステップ毎にrはxの半分以下の値になり、割られる数が半分以下になっていくので時間計算量は(log2(y))です。\n空間計算量は追加のメモリを必要としないのでO(1)です。
detailStr = 初期設定\nランダム生成ボタンで2から999までのランダムな二つの自然数x,yを生成します、x,yの下のテキストボックスに三桁以内の自然数を入力する事で手動でx,yの初期値を決定できます。ステップボタンでユークリッドの互除法を１ステップ進めます、またこの時x > yになるように値がスワップされます。\n※ステップボタンを一度押すと設定は変更不可です

[sieveOfEratosthenes]
str = エラトステネスの篩は、指定された範囲内の全ての素数を効率よく見つけるアルゴリズムです。具体的には、2から始めてその倍数をすべて消去し、次に残っている最小の数の倍数を消去するというプロセスを繰り返します。消去が終わった後に残っている数が素数です。\nこのアルゴリズムの詳しい計算量解析は複雑な為省きますが、時間計算量はO(nlog2(log2(n)))です。\n空間計算量は、範囲内の数を保持する配列に依存するためO(n)です。
detailStr = 初期設定\nランダム生成ボタンで2から99までの自然数nを生成します、nの下のテキストボックスに2から99までの整数を入力する事でエラトステネスの篩を適用する数を決定できます。ステップボタンでエラトステネスの篩を１ステップ進めます。\n※ステップボタンを一度押すと設定は変更不可です

[cumulativeSum]
str = 累積和は、配列内の任意の範囲の和を高速に計算するために使用されるアルゴリズムです。事前に配列の先頭から各要素までの累積和を求めておき、範囲の和は累積和の差分として求めます。これにより、範囲の和をO(1)で計算できます。\nまた、和と差の関係と同じように積と商でも成り立つので区間の積を高速に求める累積積も出来ます。\n累積和を事前に計算する際の時間計算量はO(n)で、空間計算量もO(n)です。
detailStr = 初期設定\nランダム生成ボタンで1から99までの要素で構成された配列をランダムに生成します。\nL,Rの下のテキストボックスに1から10までの整数を入力する事で、配列のL番目からR番目までの和を計さんする時の範囲を決定します。\nステップボタンを一度押す事で累積和を構築します、もう一度押す事で範囲の和を計算します。\n※ステップボタンを一度押すと累積和の再構築は不可ですがL,Rを変更して範囲の和を求める事は可能です。

[breadthFirstSearchGraph]
str = ある地点からある地点までの最短経路を見つける為のアルゴリズムであり、すべての経路を一度に探索していくため、どのような構造でも最短経路を確実に見つける事が出来ます。\nまた、キューという先入れ先出しデータ構造を使う事で、探索する候補を管理しています。最悪の場合でも同じ頂点から複数回探索する事はないので頂点数をn、辺の数をmとすると時間計算量はO(n + m)になります。\n空間計算量はキューを最大n頂点分使うのでO(n)です。
detailStr = 初期設定\nサンプルボタンでサンプルのグラフを生成します、A to Bの下の二つのテキストボックスに1から10の整数を入力して辺を追加ボタンを押す事で頂点Aと頂点Bの間に辺を生成します。\nランダムな辺を追加ボタンでランダムに辺を追加します。初期化ボタンを押す事で全ての辺を削除します。\nステップボタンを押す事で幅優先探索を実行します。※ステップボタンを一度押すと設定は変更不可です

[depthFirstSearchGraph]
str =  迷路やグラフを探索する際に、まず可能な限り一つの方向に深く進み、その後に戻って別の道を探索するアルゴリズムです。このアルゴリズムは、最初にスタート地点から一方向に進めるだけ進み、行き止まりに達すると、バックトラックして別の道を探索するというプロセスを繰り返します。\n最悪の場合でも同じ頂点から複数回探索する事はないので頂点数をn、辺の数をmとすると時間計算量はO(n + m)になります。\n空間計算量は、スタックを利用して次の探索地点を管理するため、探索の深さに依存しO(n)です。\n深さ優先探索は、可能な限りルートを進む性質上、必ずしも最短経路を探索出来る訳ではありません。
detailStr = 初期設定\nサンプルボタンでサンプルのグラフを生成します、A to Bの下の二つのテキストボックスに1から10の整数を入力して辺を追加ボタンを押す事で頂点Aと頂点Bの間に辺を生成します。\nランダムな辺を追加ボタンでランダムに辺を追加します。初期化ボタンを押す事で全ての辺を削除します。\nステップボタンを押す事で深さ優先探索を実行します。※ステップボタンを一度押すと設定は変更不可です

[dijkstra]
str = 辺に非負の重みを持つグラフにおいて、ある頂点から他のすべての頂点への最短経路を求めるアルゴリズムです。各頂点の暫定的な最短距離を管理し、優先度付きキューを用いて最も距離の小さい頂点を取り出しながら更新する手法を取ります。最悪の場合でも同じ頂点を重複して確定する事はないため、頂点数をn、辺の数をmとすると、時間計算量は実装によりますがO(mlog2(n))、空間計算量はO(n + m)となります。
detailStr = 初期設定\nサンプルボタンでサンプルのグラフを生成します、A to B Weightの下のテキストボックスはA,Bが貼る頂点を表してWeightがグラフの重み（距離）を表しています、辺を追加ボタンを押す事で頂点AからBへの重みWeightの辺を張ります。\nランダムボタンを押す事で現在のグラフをランダムなグラフに変更します。初期化ボタンを押す事で全ての辺を削除します。\nステップボタンを押す事でダイクストラ法を実行します。※ステップボタンを一度押すと設定は変更不可です

[topologicalSort]
str = 有向非巡回グラフ（DAG）において、頂点を辺の向きに反しない順序で並べるアルゴリズムです。入次数が0の頂点を取り出し、その頂点から出る辺を削除していくことで新たに入次数が0となる頂点を探し出す手順を繰り返していきます。\n頂点数をn、辺の数をmとすると、時間計算量はO(n + m)で、空間計算量もグラフを表すデータ構造次第でO(n + m)です。もし処理途中で頂点を取り出せなくなった場合はグラフにサイクルが存在し、トポロジカルソートは行えません。
detailStr = 初期設定\nランダムボタンでランダムサンプルのグラフを生成します。\nステップボタンでトポロジカルソートを１ステップ進めます。\n※ステップボタンを一度押すと設定は変更不可です

[selectionSort]
str = 未整列の部分に着目し、その中で最小（もしくは最大）の要素を探索して先頭の要素と交換する操作を繰り返すアルゴリズムです。\n要素数をnとすると、最悪の場合は要素を探す操作にO(n)時間、これをn回繰り返すため時間計算量はO(n^2)、空間計算量は追加のメモリを必要としないのでO(1)です。
detailStr = 初期設定\nランダムシャッフルボタンでソート対象の配列をランダムにシャッフルします、ステップボタンで選択ソートを１ステップ進めます。\n※ステップボタンを一度押すと設定は変更不可です

[bubbleSort]
str = 隣接する要素同士を比較して必要に応じて交換し、段階的に整列を完了させるアルゴリズムです。\n要素数をnとすると、要素の比較と交換を複数回行うため時間計算量はO(n^2)、空間計算量は追加のメモリを必要としないのでO(1)です。
detailStr = 初期設定\nランダムシャッフルボタンでソート対象の配列をランダムにシャッフルします、ステップボタンでバブルソートを１ステップ進めます。\n※ステップボタンを一度押すと設定は変更不可です

[quickSort]
str = クイックソートは、配列からピボット（基準となる要素）を選び、ピボットより小さい要素群と大きい要素群に分割して再帰的にソートする分割統治法の一種です。\n要素数をnとすると平均的な時間計算量はO(nlog2(n))ですが、分割の状態によってはO(n^2)になる可能性があります。空間計算量は、再帰呼び出しのスタック深度に依存しO(log2(n))程度です。\nピボットの選び方はアルゴリズム全体の性能に大きく影響します。以下のようないくつかの方法があります。 \n- 先頭や末尾など、固定の位置をピボットとする  \n- ランダムに選択する  \n- 配列の中央位置をピボットとする  \n- 中央値や中央値付近（例: 三つの要素の中央値）を用いる  \nまた今回は(left + right) / 2で求めた中間の位置をピボットに設定し、要素を分割しています。
detailStr = 初期設定\nランダムシャッフルボタンでソート対象の配列をランダムにシャッフルします、ステップボタンでクイックソートを１ステップ進めます。\n※ステップボタンを一度押すと設定は変更不可です

[hillClimbing]
str = 局所探索アルゴリズムの一つで、現在の解の近傍により良い解があれば移動を繰り返すことで解を改善する手法です。アルゴリズムの性質上初期解に大きく依存し、初期解から到達できる局所的最適解に到達する可能性は高いですが、局所的最適解からは脱出できません。\n評価関数や初期解、近傍の定義に強く依存するため、一概に計算量を示すのは難しいですが、一度の探索ステップあたりの時間は近傍の評価に要する計算量に左右されます。空間計算量は、現在の解と近傍評価に必要なデータを保持する程度で O(1) となる場合が多いです。
detailStr = 初期設定\n左上4個のスライダーはプロットしているグラフy = ax^3 + bx^2 + cx + dの係数を変更できます。\n初期値で最初のxの値を決定し、最大探索回数は最大の探索回数を決定します。\nステップボタンを押す事で山登り法を実行します。\n※ステップボタンを一度押すと設定は変更不可です

[simulatedAnnealing]
str = 山登り法に温度パラメータを導入し、確率的に悪化する解も受け入れながら最適解を探索する手法です。温度が高い序盤は大きく探索範囲を広げ、温度が下がるにつれて局所探索に移行していきます。確率的に悪い解も取りうるので山登り法で問題点だった局所的最適解に陥るという問題を防げます、ただし探索ステップが少ないと局所的最適解に行くことすらできないので探索回数が十分である必要があります。\n探索ステップ数をt、近傍の評価回数をkとすると時間計算量は概ね O(tk)、空間計算量は制御パラメータや評価関数次第で変わりますが、基本的には O(1) です。
detailStr = 初期設定\n左上4個のスライダーはプロットしているグラフy = ax^3 + bx^2 + cx + dの係数を変更できます。\n初期値で最初のxの値を決定し、最大探索回数は最大の探索回数を決定します。\n開始温度で焼きなまし法の初期温度を決定し、減衰率で各ステップ後の温度の減衰を決めます。\nステップボタンを押す事で焼きなまし法を実行します。\n※ステップボタンを一度押すと設定は変更不可です

[monteCarlo]
str = 確率論的手法を用いてランダムにサンプルを生成し、統計的に評価することで近似解や特定の値（例: 円周率など）を求めるアルゴリズムです。円周率を推定する場合は、s個の乱数点を生成し、それぞれが単位円内に収まるかを判定します。各点の生成および判定はいずれも定数時間O(1)で実行できるため、アルゴリズム全体の時間計算量はO(s)となります。メモリ使用量は、生成した点をすべて保持する実装においてはO(s)となりますが、点の内外判定結果のみをカウントする設計にすれば、空間計算量は追加のメモリを必要としないのでO(1)に抑えることも可能です。
detailStr = 初期設定\n点/ステップスライダーを動かす事で毎ステップ事に生成する点の数を変更できます、ステップボタンを押す事でモンテカルロ法を実行します。

[selectAndExplainAlgorithm]
algorithmDetails1 = 配列やリストなどのデータ構造から特定の要素を探索するアルゴリズムの一つです。\nこのアルゴリズムは、データの先頭から順番に一つずつ要素をチェックし、目的の要素を見つけるまで繰り返します。見つけたらその時点で探索を終了し、見つからなければすべての要素を確認し終えた後に探索が終了します。
algorithmDetails2 = 整列されたデータ（昇順または降順に並んだ配列）から特定の要素を効率的に探すアルゴリズムです。探索の手順は以下の通りです。\n1...配列の中央の要素を確認します。\n2...その要素が探している値と一致するか確認します。一致しない場合、探している値が中央の要素よりも小さいなら、配列の左半分を対象に探索を続け、大きいなら右半分を対象にします。\n3...上記の手順を繰り返し、探している要素を見つけるか、配列の範囲がゼロになるまで続けます。
algorithmDetails3 = 迷路やグラフの探索において、スタート地点からゴール地点までの最短経路を見つけるためのアルゴリズムです。このアルゴリズムは、探索の範囲を広げるようにして進んでいきます。手順は以下の通りです。\n1...スタート地点から探索を始め、スタート地点を探索済みとして記録します\n2...探索済みの地点に隣接する全ての未探索の地点を探索する予定を表すキューに追加します。\n3...キューから地点を取り出し、その地点がゴール地点か確認します。\n4...ゴール地点でない場合、その地点の隣接する未探索の地点を再度キューに追加します。\n5...この手順を繰り返し、ゴール地点が見つかるか、キューが空になるまで続けます。\nここで用いるキューというデータ構造は先入れ先出しのデータ構造です。先に追加された要素が先に取り出されます。
algorithmDetails4 = 迷路やグラフの探索において、スタート地点からゴール地点までのパスを探索するアルゴリズムです。このアルゴリズムは、可能な限り一つの方向に深く進んでいく特徴があります。ただしこのアルゴリズムでは最短経路が見つかるとは限りません。手順は以下の通りです。\n1...スタート地点から探索を始め、スタート地点を探索済みとして記録します\n2...探索済みの地点に隣接する全ての未探索の地点を探索する予定を表すスタックに追加します。\n3...スタックから地点を取り出し、その地点がゴール地点か確認します。\n4...ゴール地点でない場合、その地点からさらに進むことができる隣接地点を再度スタックに追加します。\n5...進める地点がなくなった場合、スタックから次の地点を取り出して別の道を探索します。\n6...この手順を繰り返し、ゴール地点が見つかるか、スタックが空になるまで続けます。\nここで用いるスタックというデータ構造は後入れ先出しのデータ構造です。最後に追加された要素が最初に取り出されます。
algorithmDetails5 = ユークリッドの互除法は、2つの整数の最大公約数（GCD）を効率的に求めるアルゴリズムです。\nこの方法は、2つの数を割り算し、その余りを使って次々に割り算を繰り返すことで、最終的に余りが0になった時の割られる数が最大公約数になります。
algorithmDetails6 = エラトステネスの篩は、指定された整数までの素数を効率よく求めるアルゴリズムです。この方法は、リストから素数でない数を順次取り除くことで、素数だけを残すという仕組みです。手順は以下の通りです。\n1...2から指定された整数までのすべての整数をリストに書き出します。\n2...最初の素数である2を選び、その倍数すべてをリストから削除します（ただし、2自身は削除しません）。\n3...リスト上で次にまだ削除されていない数を見つけ、その数を素数として記録し、その倍数すべてを削除します。\n4...選んだ数が指定された整数の平方根を超えるまで、この手順を繰り返します。\n5...最後にリストに残ったすべての数が素数となります。
algorithmDetails7 = 累積和は、数列に対して前計算を用いて効率的に部分和を計算するためのアルゴリズムです。数列の各要素までの累計の和を事前に計算しておき、任意の区間の和を高速に求めることができます。手順は以下の通りです。\n1...元の数列を配列 A とし、累積和の配列 S を用意します。累積和の各要素 S[i] は、数列 A の先頭から i 番目までの要素の和を表します。\nS[i] = A[0] + A[1] + ... + A[i]\n2...指定された区間 A[l], A[l+1], ..., A[r] の和は、累積和 S[r] と S[l - 1] を使って次のように求められます。\n区間和 = S[r] - S[l - 1]\n累積和を使うことで、部分和の計算が効率的に行えます。
algorithmDetails8 = 迷路やグラフの探索において、スタート地点からゴール地点までの最短経路を見つけるためのアルゴリズムです。このアルゴリズムは、探索の範囲を広げるようにして進んでいきます。手順は以下の通りです。\n1...スタート地点から探索を始め、スタート地点を探索済みとして記録します\n2...探索済みの地点に隣接する全ての未探索の地点を探索する予定を表すキューに追加します。\n3...キューから地点を取り出し、その地点がゴール地点か確認します。\n4...ゴール地点でない場合、その地点の隣接する未探索の地点を再度キューに追加します。\n5...この手順を繰り返し、ゴール地点が見つかるか、キューが空になるまで続けます。\nここで用いるキューというデータ構造は先入れ先出しのデータ構造です。先に追加された要素が先に取り出されます。\nこの項目では迷路では無くグラフ上で幅優先探索を行います。
algorithmDetails9 = 迷路やグラフの探索において、スタート地点からゴール地点までのパスを探索するアルゴリズムです。このアルゴリズムは、可能な限り一つの方向に深く進んでいく特徴があります。ただしこのアルゴリズムでは最短経路が見つかるとは限りません。手順は以下の通りです。\n1...スタート地点から探索を始め、スタート地点を探索済みとして記録します\n2...探索済みの地点に隣接する全ての未探索の地点を探索する予定を表すスタックに追加します。\n3...スタックから地点を取り出し、その地点がゴール地点か確認します。\n4...ゴール地点でない場合、その地点からさらに進むことができる隣接地点を再度スタックに追加します。\n5...進める地点がなくなった場合、スタックから次の地点を取り出して別の道を探索します。\n6...この手順を繰り返し、ゴール地点が見つかるか、スタックが空になるまで続けます。\nここで用いるスタックというデータ構造は後入れ先出しのデータ構造です。最後に追加された要素が最初に取り出されます。\nこの項目では迷路では無くグラフ上で深さ優先探索を行います。
algorithmDetails10 = グラフ上の各頂点に対し、出発点からの最短距離を順次更新して求めるアルゴリズムです。  \n実行時は、出発点の距離を0、その他の頂点を無限大と初期化し、優先度付きキューで探索を進めます。  \n具体的な手順は以下の通りです。\n1...出発点を初期キューに登録する。\n2...キューから現在の最短距離を持つ頂点を取り出す。\n3...その頂点に隣接する各頂点の距離を、現在の頂点経由での距離と比較し、短い場合に更新する。\n4...更新があった頂点を再度キューに登録し、すべての頂点の更新が終わるまで繰り返す。\nここで用いる優先度付きキューというデータ構造は優先度付きのデータを扱う場合のキューです。常に優先度が一番高い物が取り出されます。
algorithmDetails11 = 有向グラフにおいて、頂点を「辺の向きに従った順序」で並べるためのアルゴリズムです。  \n特に有向非巡回グラフ（DAG）でのみ適用可能で、サイクルを含むグラフには利用できません。  \n手順は以下の通りです。\n1... 有向グラフの頂点のうち、入次数（ある頂点への辺の数）が0の頂点を探索予定リスト（キュー）に追加します。\n2... キューから頂点を取り出し、これをトポロジカル順序の結果リストに追加します。 \n3... 取り出した頂点から伸びる辺をすべて削除し、削除した先の頂点の入次数を1減らします。\n4... 入次数が0になった頂点があれば、その頂点を再度キューに追加します。\n5... キューが空になるまで2〜4を繰り返し、処理した頂点の順番がトポロジカルソートの結果となります。
algorithmDetails12 = 整列対象の配列から、未整列部分の中で最小（または最大）の要素を選び出し、先頭部分と交換する手法です。  \n具体的な手順は以下の通りです。\n1...配列全体を走査し、最小値の位置を検出する。\n2...その値と、検査対象の先頭要素を交換する。\n3...先頭の位置を固定し残りの配列に対して同様の操作を再帰的に実施する。\n4...配列全体が整列されるまで繰り返す。
algorithmDetails13 = 隣接する要素を順に比較し、必要に応じて交換することでリスト全体を整列させるアルゴリズムです。  \n具体的な手順は以下の通りです。\n1...配列の先頭から隣接する要素を比較する。\n2...順序が逆の場合は要素を入れ替える。\n3...配列末尾までこの操作を繰り返し、1回のパスが終了したら、再度先頭から比較を始める。\n4...入れ替えが発生しなくなるまで続ける。
algorithmDetails14 = 分割統治法に基づいて、基準（ピボット）を選び、配列をピボットより小さい部分と大きい部分に分割し、それぞれを再帰的に整列する手法です。  \n具体的な手順は以下の通りです。\n1...配列からピボットとなる要素を選択する。\n2...ピボットより小さい要素群と大きい要素群に分割する。\n3...それぞれの部分配列に対して再帰的にクイックソートを適用する。\n4...再帰呼び出しの結果を結合し、完全な整列配列とする。
algorithmDetails15 = 局所最適解を探索するために、現在の解の近傍から改善可能な解へ逐次更新していく手法です。  \n具体的な手順は以下の通りです。\n1...ランダムまたは指定された初期解を設定する。\n2...現在の解の近傍を評価し、より良い解が存在するか確認する。\n3...改善が見込める解があれば移動し、同様の評価を続ける。\n4...近傍に改善が見られなくなった時点で解を確定する。
algorithmDetails16 = 温度パラメータに基づいて、確率的に悪化する解も受け入れながら最適解を探索する手法です。  \n具体的な手順は以下の通りです。\n1...初期状態と初期温度を設定する。\n2...近傍の解をランダムに選び、その評価値の変化を計算する。\n3...評価が悪化する場合でも、温度に応じた確率で解を更新する。\n4...温度を徐々に下げ、収束または停止条件に達するまで繰り返す。
algorithmDetails17 = 確率論的手法を用いてランダムサンプルを大量に生成し、統計的に評価を行うアルゴリズムです。ここでは円周率の推定を行います。\n具体的な手順は以下の通りです。\n1...二次元平面上の[-1, 1]の範囲にランダムな点を生成します。\n2...各点について円内かどうかを判定して数を記録します\n3...円内にある点の数と全体の点の数から、円周率の推定値 4 × (円内の点の数 / 全点数) を算出します。\n4...このプロセスをステップごとに繰り返し、円周率を求めます。\nこの手法は円周率に限らず、数値積分や統計的シミュレーションなど多岐にわたる分野で応用されています。
