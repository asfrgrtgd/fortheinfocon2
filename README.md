# アルゴリズムビジュアライザ

## 概要
C++とsiv3dを用いて作成した、アルゴリズムを可視化してアルゴリズムの理解を深めるソフト

## セットアップガイド

1. **圧縮ファイルの展開**  
   ダウンロードしたzipファイルを任意の作業フォルダに解凍します。

2. **環境の整備**  
   このプロジェクトはC++と[siv3d](https://siv3d.github.io/)を利用しています。  
   - [Visual Studio 2022](https://visualstudio.microsoft.com/ja/downloads/)をインストールします。
   - Visual Studio 2022のインストーラ実行して、プログラミング言語や開発ツールを選択する画面で、C++によるデスクトップ開発を選択してインストールします。
   - [Open Siv 3d](https://siv3d.github.io/ja-jp/download/windows/)からOpenSiv3D v0.6.15 Installer for Windows Desktopをダウンロードします
   - 管理者権限でインストーラを実行します。

3. **プロジェクトの読み込み**  
   解凍後、algorithmVisualizer/algorithmVisualizer.sln をVisual StudioまたはVisual Studio Codeで開きます。  

4. **ビルド**  
   - Visual Studioの場合：algorithmVisualizer/algorithmVisualizer.sln ソリューションを開いた後、デバッグまたはリリース構成を選択し、ビルドします。  

5. **実行**  
   ビルドが成功すると、アプリが起動します。また同封しているAppフォルダ内に存在しているalgorithmVisualizer.exeからも実行できます。

## アルゴリズムの種類

### 探索
線形探索,二分探索,幅優先探索(グリッド迷路),深さ優先探索(グリッド迷路)

### 数学
ユークリッドの互除法,エラストテネスの篩,累積和

### グラフ
幅優先探索,深さ優先探索,ダイクストラ法,トポロジカルソート

### ソート
選択ソート,バブルソート,クイックソート

### その他
山登り法,焼きなまし法,モンテカルロ法

## シーン遷移
アルゴリズムのジャンル選択 <-> アルゴリズム選択と簡単な説明 <-> アルゴリズムの実行と可視化 <-> アルゴリズムの詳細な説明

## ファイル構成

シーンをベースにしてファイルを分割する、各アルゴリズムの実行と可視化のクラスはrunAlgorithmsフォルダ内に存在する

### Main.cpp
シーンマネージャーのメインループと画面サイズの設定を持つcppファイル

### selectAlgorithmCategory.h
Sceneクラスを継承して作られた、アルゴリズムのジャンル選択をするselectAlgorithmCategoryクラスのクラス宣言と実装を含んだヘッダーファイル

### selectAndExplainAlgorithm.h
Sceneクラスを継承して作られた、アルゴリズムの選択と簡単な説明をするselectAndExplainAlgorithmクラスのクラス宣言と実装を含んだヘッダーファイル

### explainAlgorithm.h
Sceneクラスを継承して作られた、アルゴリズムの詳細な説明をするexplainAlgorithmクラスのクラス宣言と実装を含んだヘッダーファイル

解説をする為の文章はrunAlgorithmsフォルダ内のシーンから遷移した際にクラスから解説文を受け取る

### algorithmIntroduction.h
App/config.iniから定数や文章を取り出す為の関数の宣言と実装を含んだヘッダーファイル

### algorithmVisualizerDefs.h
ボタンの大きさの定義と開発用デバッグモードのオンオフを切り替えるヘッダーファイル

### mazeSearchDef.h
迷路探索アルゴリズムで使用する迷路の定義と迷路に関する関数

### graphSearchDef.h
グラフ探索アルゴリズムで使用する迷路の定義とグラフに関する関数

### App/config.ini
画面の大きさ、背景の色やアルゴリズムの簡易説明文、詳細説明文、初期ステップ説明文を持つ.iniファイル

### runAlgorithms/linearSearch.h
Sceneクラスを継承して作られた、線形探索の実行と可視化を行うlinearSearchクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に、クラス内にApp/config.iniから参照した説明文を保持する

### runAlgorithms/binarySearch.h
Sceneクラスを継承して作られた、二分探索の実行と可視化を行うbinarySearchクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に、クラス内にApp/config.iniから参照した説明文を保持する

### runAlgorithms/breadthFirstSearch.h
Sceneクラスを継承して作られた、幅優先探索の実行と可視化を行うbreadthFirstSearchクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に、クラス内にApp/config.iniから参照した説明文を保持する

### runAlgorithms/depthFirstSearch.h
Sceneクラスを継承して作られた、深さ優先探索の実行と可視化をするdepthFirstSearchクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/euclideanAlgorithm.h
Sceneクラスを継承して作られた、ユークリッドの互除法の実行と可視化をするeuclideanAlgorithmクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/sieveOfEratosthenes.h
Sceneクラスを継承して作られた、エラトステネスの篩の実行と可視化をするsieveOfEratosthenesクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/cumulativeSum.h
Sceneクラスを継承して作られた、累積和の実行と可視化をするcumulativeSumクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/breadthFirstSearchGraph.h
Sceneクラスを継承して作られた、グラフ上の幅優先探索の実行と可視化をするbreadthFirstSearchGraphクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/depthFirstSearchGraph.h
Sceneクラスを継承して作られた、グラフ上の深さ優先探索の実行と可視化をするdepthFirstSearchGraphクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/dijkstra.h
Sceneクラスを継承して作られた、ダイクストラ法の実行と可視化をするdijkstraクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/topologicalSort.h
Sceneクラスを継承して作られた、トポロジカルソートの実行と可視化を行うtopologicalSortクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/selectionSort.h
Sceneクラスを継承して作られた、選択ソートの実行と可視化を行うselectionSortクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/bubbleSort.h
Sceneクラスを継承して作られた、バブルソートの実行と可視化を行うbubbleSortクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/quickSort.h
Sceneクラスを継承して作られた、クイックソートの実行と可視化を行うquickSortクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/hillClimbing.h
Sceneクラスを継承して作られた、山登り法（局所探索）の実行と可視化を行うhillClimbingクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/simulatedAnnealing.h
Sceneクラスを継承して作られた、焼きなまし法の実行と可視化を行うsimulatedAnnealingクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

### runAlgorithms/monteCarlo.h
Sceneクラスを継承して作られた、モンテカルロ法の実行と可視化を行うmonteCarloクラスのクラス宣言と実装を含んだヘッダーファイル

explainAlgorithmに遷移する際に解説文を渡す為にクラス内にApp/config.iniから参照した説明文を持つ

## 各アルゴリズムの簡易説明

### 線形探索

配列やリストなどのデータ構造から特定の要素を探索するアルゴリズムの一つです。このアルゴリズムは、データの先頭から順番に一つずつ要素をチェックし、目的の要素を見つけるまで繰り返します。見つけたらその時点で探索を終了し、見つからなければすべての要素を確認し終えた後に探索が終了します。

### 二分探索
整列されたデータ（昇順または降順に並んだ配列）から特定の要素を効率的に探すアルゴリズムです。探索の手順は以下の通りです。

1...配列の中央の要素を確認します。

2...その要素が探している値と一致するか確認します。
一致しない場合、探している値が中央の要素よりも小さいなら、配列の左半分を対象に探索を続け、大きいなら右半分を対象にします。

3...上記の手順を繰り返し、探している要素を見つけるか、配列の範囲がゼロになるまで続けます。

### 幅優先探索(グリッド迷路)
迷路やグラフの探索において、スタート地点からゴール地点までの最短経路を見つけるためのアルゴリズムです。このアルゴリズムは、探索の範囲を広げるようにして進んでいきます。手順は以下の通りです。

1...スタート地点から探索を始め、スタート地点を探索済みとして記録します。

2...探索済みの地点に隣接する全ての未探索の地点を探索する予定を表すキューに追加します。

3...キューから地点を取り出し、その地点がゴール地点か確認します。

4...ゴール地点でない場合、その地点の隣接する未探索の地点を再度キューに追加します。

5...この手順を繰り返し、ゴール地点が見つかるか、キューが空になるまで続けます。

ここで用いるキューというデータ構造は先入れ先出しのデータ構造です。先に追加された要素が先に取り出されます。

### 深さ優先探索(グリッド迷路)
迷路やグラフの探索において、スタート地点からゴール地点までのパスを探索するアルゴリズムです。このアルゴリズムは、可能な限り一つの方向に深く進んでいく特徴があります。ただしこのアルゴリズムでは最短経路が見つかるとは限りません。
手順は以下の通りです。

1...スタート地点から探索を始め、スタート地点を探索済みとして記録します。

2...探索済みの地点に隣接する全ての未探索の地点を探索する予定を表すスタックに追加します。

3...スタックから地点を取り出し、その地点がゴール地点か確認します。

4...ゴール地点でない場合、その地点からさらに進むことができる隣接地点を再度スタックに追加します。

5...進める地点がなくなった場合、スタックから次の地点を取り出して別の道を探索します。

6...この手順を繰り返し、ゴール地点が見つかるか、スタックが空になるまで続けます。

ここで用いるスタックというデータ構造は後入れ先出しのデータ構造です。最後に追加された要素が最初に取り出されます。

### ユークリッドの互除法
ユークリッドの互除法は、2つの整数の最大公約数（GCD）を効率的に求めるアルゴリズムです。この方法は、2つの数を割り算し、その余りを使って次々に割り算を繰り返すことで、最終的に余りが0になった時の割られる数が最大公約数になります。

### エラトステネスの篩
エラトステネスの篩は、指定された整数までの素数を効率よく求めるアルゴリズムです。この方法は、リストから素数でない数を順次取り除くことで、素数だけを残すという仕組みです。手順は次の通りです。

1...2から指定された整数までのすべての整数をリストに書き出します。

2...最初の素数である2を選び、その倍数すべてをリストから削除します（ただし、2自身は削除しません）。

3...リスト上で次にまだ削除されていない数を見つけ、その数を素数として記録し、その倍数すべてを削除します。

4...選んだ数が指定された整数の平方根を超えるまで、この手順を繰り返します。

5...最後にリストに残ったすべての数が素数となります。

### 累積和
累積和は、数列に対して前計算を用いて効率的に部分和を計算するためのアルゴリズムです。数列の各要素までの累計の和を事前に計算しておき、任意の区間の和を高速に求めることができます。手順は以下の通りです。

1...元の数列を配列 A とし、累積和の配列 S を用意します。累積和の各要素 S[i] は、数列 A の先頭から i 番目までの要素の和を表します。
  S[i] = A[0] + A[1] + ... + A[i]

2...指定された区間 A[l], A[l+1], ..., A[r] の和は、累積和 S[r] と S[l - 1] を使って次のように求められます。
  区間和 = S[r] - S[l - 1]

累積和を使うことで、部分和の計算が効率的に行えます。

### 幅優先探索
迷路やグラフの探索において、スタート地点からゴール地点までの最短経路を見つけるためのアルゴリズムです。このアルゴリズムは、探索の範囲を広げるようにして進んでいきます。手順は以下の通りです。

1...スタート地点から探索を始め、スタート地点を探索済みとして記録します

2...探索済みの地点に隣接する全ての未探索の地点を探索する予定を表すキューに追加します。

3...キューから地点を取り出し、その地点がゴール地点か確認します。

4...ゴール地点でない場合、その地点の隣接する未探索の地点を再度キューに追加します。

5...この手順を繰り返し、ゴール地点が見つかるか、キューが空になるまで続けます。

ここで用いるキューというデータ構造は先入れ先出しのデータ構造です。先に追加された要素が先に取り出されます。

この項目では迷路ではなくグラフ上で幅優先探索を行います。

### 深さ優先探索
迷路やグラフの探索において、スタート地点からゴール地点までのパスを探索するアルゴリズムです。このアルゴリズムは、可能な限り一つの方向に深く進んでいく特徴があります。ただしこのアルゴリズムでは最短経路が見つかるとは限りません。
手順は以下の通りです。

1...スタート地点から探索を始め、スタート地点を探索済みとして記録します

2...探索済みの地点に隣接する全ての未探索の地点を探索する予定を表すスタックに追加します。

3...スタックから地点を取り出し、その地点がゴール地点か確認します。

4...ゴール地点でない場合、その地点からさらに進むことができる隣接地点を再度スタックに追加します。

5...進める地点がなくなった場合、スタックから次の地点を取り出して別の道を探索します。

6...この手順を繰り返し、ゴール地点が見つかるか、スタックが空になるまで続けます。

ここで用いるスタックというデータ構造は後入れ先出しのデータ構造です。最後に追加された要素が最初に取り出されます。

この項目では迷路ではなくグラフ上で深さ優先探索を行います

### ダイクストラ法
グラフ上の各頂点に対し、出発点からの最短距離を順次更新して求めるアルゴリズムです。  
実行時は、出発点の距離を0、その他の頂点を無限大と初期化し、優先度付きキューで探索を進めます。  
具体的な手順は以下の通りです。

1...出発点を初期キューに登録する。

2...キューから現在の最短距離を持つ頂点を取り出す。

3...その頂点に隣接する各頂点の距離を、現在の頂点経由での距離と比較し、短い場合に更新する。

4...更新があった頂点を再度キューに登録し、すべての頂点の更新が終わるまで繰り返す。

ここで用いる優先度付きキューというデータ構造は優先度付きのデータを扱う場合のキューです。常に優先度が一番高い物が取り出されます。

### トポロジカルソート
有向グラフにおいて、頂点を「辺の向きに従った順序」で並べるためのアルゴリズムです。  
特に有向非巡回グラフ（DAG）でのみ適用可能で、サイクルを含むグラフには利用できません。  
手順は以下の通りです。

1... 有向グラフの頂点のうち、入次数（ある頂点への辺の数）が0の頂点を探索予定リスト（キュー）に追加します。  
2... キューから頂点を取り出し、これをトポロジカル順序の結果リストに追加します。  
3... 取り出した頂点から伸びる辺をすべて削除し、削除した先の頂点の入次数を1減らします。  
4... 入次数が0になった頂点があれば、その頂点を再度キューに追加します。  
5... キューが空になるまで1〜4を繰り返し、処理した頂点の順番がトポロジカルソートの結果となります。

### 選択ソート
整列対象の配列から、未整列部分の中で最小（または最大）の要素を選び出し、先頭部分と交換する手法です。  
具体的な手順は以下の通りです。

1...配列全体を走査し、最小値の位置を検出する。

2...その値と、検査対象の先頭要素を交換する。

3...先頭の位置を固定し、残りの配列に対して同様の操作を再帰的に実施する。

4...配列全体が整列されるまで繰り返す。

### バブルソート
隣接する要素を順に比較し、必要に応じて交換することでリスト全体を整列させるアルゴリズムです。  
具体的な手順は以下の通りです。

1...配列の先頭から隣接する要素を比較する。

2...順序が逆の場合は要素を入れ替える。

3...配列末尾までこの操作を繰り返し、1回のパスが終了したら、再度先頭から比較を始める。

4...入れ替えが発生しなくなるまで続ける。

### クイックソート
分割統治法に基づいて、基準（ピボット）を選び、配列をピボットより小さい部分と大きい部分に分割し、それぞれを再帰的に整列する手法です。  
具体的な手順は以下の通りです。

1...配列からピボットとなる要素を選択する。

2...ピボットより小さい要素群と大きい要素群に分割する。

3...それぞれの部分配列に対して再帰的にクイックソートを適用する。

4...再帰呼び出しの結果を結合し、完全な整列配列とする。

### 山登り法
局所最適解を探索するために、現在の解の近傍から改善可能な解へ逐次更新していく手法です。  
具体的な手順は以下の通りです。

1...ランダムまたは指定された初期解を設定する。

2...現在の解の近傍を評価し、より良い解が存在するか確認する。

3...改善が見込める解があれば移動し、同様の評価を続ける。

4...近傍に改善が見られなくなった時点で解を確定する。

### 焼きなまし法
温度パラメータに基づいて、確率的に悪化する解も受け入れながら最適解を探索する手法です。  
具体的な手順は以下の通りです。

1...初期状態と初期温度を設定する。

2...近傍の解をランダムに選び、その評価値の変化を計算する。

3...評価が悪化する場合でも、温度に応じた確率で解を更新する。

4...温度を徐々に下げ、収束または停止条件に達するまで繰り返す。

### モンテカルロ法
確率論的手法を用いてランダムサンプルを大量に生成し、統計的に評価を行うアルゴリズムです。ここでは円周率の推定を行います。
具体的な手順は以下の通りです。

1...二次元平面上の[-1, 1]の範囲にランダムな点を生成します。

2...各点について円内かどうかを判定して数を記録します

3...円内にある点の数と全体の点の数から、円周率の推定値 4 × (円内の点の数 / 全点数) を算出します。

4...このプロセスをステップごとに繰り返し、円周率を求めます。

この手法は円周率に限らず、数値積分や統計的シミュレーションなど多岐にわたる分野で応用されています。

## 各アルゴリズムの詳細説明

### 線形探索
全ての要素を一つづつ確認するという非常にシンプルなアルゴリズムであり、データの整列や前処理が要らないため、汎用性が高いアルゴリズムです。ただし、要素数nとして最悪の場合にはすべての要素を確認する必要があるため時間計算量がO(n)です。処理された大きいデータ構造や何回も同じデータ構造を探索をする際には、二分探索O(log2(n))より遅くなる可能性があります。空間計算量は追加のメモリを必要としないのでO(1)です。

### 二分探索
データ構造や関数や数列に対してある要素が存在するか探したり、ある要素以下の最大の数を探したりする際に使えるアルゴリズムです。このアルゴリズムは探索する対象のデータ構造が単調性を持っている事が条件です。ここでの単調性とは全ての要素間を比較したときにv[k] <= v[k + 1]もしくはv[k] >= v[k + 1] (v[k]は配列のk番目の要素)が成り立つ事を意味します探索範囲は各ステップで1/2ずつ減っていくので最悪のケースでもlog2(n)回になり、時間計算量はO(log2(n))と高速です。空間計算量は追加のメモリを必要としないのでO(1)です。。

### 幅優先探索
ある地点からある地点までの最短経路を見つける為のアルゴリズムであり、すべての経路を一度に探索していくため、どのような構造でも最短経路を確実に見つける事が出来ます。また、キューという先入れ先出しデータ構造を使う事で、探索する候補を管理しています。最悪の場合でも同じマスから複数回探索する事はないのでマス目をnとして時間計算量はO(n)になります。空間計算量はキューを最大nマス分使うのでO(n)です。

### 深さ優先探索
迷路やグラフを探索する際に、まず可能な限り一つの方向に深く進み、その後に戻って別の道を探索するアルゴリズムです。このアルゴリズムは、最初にスタート地点から一方向に進めるだけ進み、行き止まりに達すると、バックトラックして別の道を探索するというプロセスを繰り返します。最悪の場合でも同じマスから複数回探索する事はないのでマス目をnとして時間計算量はO(n)になります。空間計算量は、スタックを利用して次の探索地点を管理するため、探索の深さに依存しO(n)です。深さ優先探索は、可能な限りルートを進む性質上、必ずしも最短経路を探索出来る訳ではありません。

### ユークリッドの互除法
最大公約数を効率よく求めるアルゴリズムです、具体的には二つの整数x,y(x > y)をxをyで割り、その余りrをrが0になるまでxにyを代入して、yにrを代入するという動作を繰り返し、yの値が最終的にx,byの最大公約数になります。このアルゴリズムの計算量の導出はステップを二つの場合に分けて導きます、y <= x / 2の時rはr < y <= x / 2になり、y > x / 2の時は割り切れないのでr = x - yとなりr < x / 2になります。そのためステップ毎にrはxの半分以下の値になり、割られる数が半分以下になっていくので時間計算量はO(log2(y))です。空間計算量は追加のメモリを必要としないのでO(1)です。

### エラトステネスの篩
エラトステネスの篩は、指定された範囲内の全ての素数を効率よく見つけるアルゴリズムです。具体的には、2から始めてその倍数をすべて消去し、次に残っている最小の数の倍数を消去するというプロセスを繰り返します。消去が終わった後に残っている数が素数です。このアルゴリズムの詳しい計算量解析は複雑な為省きますが、時間計算量はO(n log2(log2(n)))です。空間計算量は、範囲内の数を保持する配列に依存するためO(n)です。

### 累積和
累積和は、配列内の任意の範囲の和を高速に計算するために使用されるアルゴリズムです。事前に配列の先頭から各要素までの累積和を求めておき、範囲の和は累積和の差分として求めます。これにより、範囲の和をO(1)で計算できます。また、和と差の関係と同じように積と商でも成り立つので区間の積を拘束に求める累積積も出来ます。累積和を事前に計算する際の時間計算量はO(n)、空間計算量もO(n)です。

### 幅優先探索
ある地点からある地点までの最短経路を見つける為のアルゴリズムであり、すべての経路を一度に探索していくため、どのような構造でも最短経路を確実に見つける事が出来ます。また、キューという先入れ先出しデータ構造を使う事で、探索する候補を管理しています。最悪の場合でも同じ頂点から複数回探索する事はないので頂点数をn、辺の数をmとすると時間計算量はO(n + m)になります。空間計算量はキューを最大n頂点分使うのでO(n)です。

### 深さ優先探索
迷路やグラフを探索する際に、まず可能な限り一つの方向に深く進み、その後に戻って別の道を探索するアルゴリズムです。このアルゴリズムは、最初にスタート地点から一方向に進めるだけ進み、行き止まりに達すると、バックトラックして別の道を探索するというプロセスを繰り返します。ここでのバックトラックとは探索の途中まで巻き戻す操作の事です。最悪の場合でも同じ頂点から複数回探索する事はないので頂点数をn、辺の数をmとすると時間計算量はO(n + m)になります。空間計算量は、スタックを利用して次の探索地点を管理するため、探索の深さに依存しO(n)です。深さ優先探索は、可能な限りルートを進む性質上、必ずしも最短経路を探索出来る訳ではありません。

### ダイクストラ法
辺に非負の重みを持つグラフにおいて、ある頂点から他のすべての頂点への最短経路を求めるアルゴリズムです。各頂点の暫定的な最短距離を管理し、優先度付きキューを用いて最も距離の小さい頂点を取り出しながら更新する手法を取ります。最悪の場合でも同じ頂点を重複して確定する事はないため、頂点数をn、辺の数をmとすると、時間計算量は実装によりますがO(mlog2(n))、空間計算量はO(n + m)となります。

### トポロジカルソート
有向非巡回グラフ（DAG）において、頂点を辺の向きに反しない順序で並べるアルゴリズムです。入次数が0の頂点を取り出し、その頂点から出る辺を削除していくことで新たに入次数が0となる頂点を探し出す手順を繰り返していきます。頂点数をn、辺の数をmとすると、時間計算量はO(n + m)で、空間計算量もグラフを表すデータ構造次第でO(n + m)です。もし処理途中で頂点を取り出せなくなった場合はグラフにサイクルが存在し、トポロジカルソートは行えません。

### 選択ソート
未整列の部分に着目し、その中で最小（もしくは最大）の要素を探索して先頭の要素と交換する操作を繰り返すアルゴリズムです。要素数をn とすると、最悪の場合は要素を探す操作にO(n)時間、これをn回繰り返すため時間計算量はO(n^2)、空間計算量は追加のメモリを必要としないのでO(1)です。

### バブルソート
隣接する要素同士を比較して必要に応じて交換し、段階的に整列を完了させるアルゴリズムです。要素数をnとすると、要素の比較と交換を複数回行うため時間計算量はO(n^2)、空間計算量は追加のメモリを必要としないのでO(1)です。

### クイックソート
クイックソートは、配列からピボット（基準となる要素）を選び、ピボットより小さい要素群と大きい要素群に分割して再帰的にソートする分割統治法の一種です。要素数をnとすると平均的な時間計算量はO(n log2(n))ですが、分割の状態によってはO(n^2)になる可能性があります。空間計算量は、再帰呼び出しのスタック深度に依存しO(log2(n))程度です。

ピボットの選び方はアルゴリズム全体の性能に大きく影響します。以下のようないくつかの方法があります。  
- 先頭や末尾など、固定の位置をピボットとする  
- ランダムに選択する  
- 配列の中央位置をピボットとする  
- 中央値や中央値付近（例: 三つの要素の中央値）を用いる  

また今回は(left + right) / 2で求めた中間の位置をピボットに設定し、要素を分割しています。

### 山登り法
局所探索アルゴリズムの一つで、現在の解の近傍により良い解があれば移動を繰り返すことで解を改善する手法です。アルゴリズムの性質上初期解に大きく依存し、初期解から到達できる局所的最適解に到達する可能性は高いですが、局所的最適解からは脱出できません。評価関数や初期解、近傍の定義に強く依存するため、一概に計算量を示すのは難しいですが、一度の探索ステップあたりの時間は近傍の評価に要する計算量に左右されます。空間計算量は、現在の解と近傍評価に必要なデータを保持する程度で O(1) となる場合が多いです。

### 焼きなまし法
山登り法に温度パラメータを導入し、確率的に悪化する解も受け入れながら最適解を探索する手法です。温度が高い序盤は大きく探索範囲を広げ、温度が下がるにつれて局所探索に移行していきます。確率的に悪い解も取りうるので山登り法で問題点だった局所的最適解に陥るという問題を防げます、ただし探索ステップが少ないと局所的最適解に行くことすらできないので探索回数が十分である必要があります。探索ステップ数をt、近傍の評価回数をkとすると時間計算量は概ね O(tk)、空間計算量は制御パラメータや評価関数次第で変わりますが、基本的には O(1) です。

### モンテカルロ法
確率論的手法を用いてランダムにサンプルを生成し、統計的に評価することで近似解や特定の値（例: 円周率など）を求めるアルゴリズムです。円周率を推定する場合は、s個の乱数点を生成し、それぞれが単位円内に収まるかを判定します。各点の生成および判定はいずれも定数時間O(1)で実行できるため、アルゴリズム全体の時間計算量はO(s)となります。メモリ使用量は、生成した点をすべて保持する実装においてはO(s)となりますが、点の内外判定結果のみをカウントする設計にすれば、空間計算量は追加のメモリを必要としないのでO(1)に抑えることも可能です。
